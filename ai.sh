#!/usr/bin/env bash

# Mode can be one of:
#   - user_entrypoint
#   - debug_prompt
#   - selector_preview
mode="user_entrypoint"
user_input=""

print_usage() {
  echo "Not implemented!"
  exit 1
}

parse_cli_preview_selection() {
  if [[ $# -ne 1 ]]; then
    echo "Error: expected 1 arg for __preview_selection__, got $#"
    exit 1
  fi

  mode="selector_preview"
  user_input="$1"
}

parse_cli() {
  if [[ "$1" == "__preview_selection__" ]]; then
    shift 1
    parse_cli_preview_selection "$@"
    return
  fi

  if [[ "$1" == "__debug_prompt__" ]]; then
    shift 1
    mode="debug_prompt"
    user_input="$1"
    return
  fi

  # If we get here, we're in user_entrypoint mode which requires 1 or more args
  if [[ $# -eq 0 ]]; then
    echo "Error: no user input provided"
    print_usage
    exit 1
  fi

  mode="user_entrypoint"
  # User might do something like
  #   $ ai.sh I want to list all the files in the directory
  # this should be equivalent to
  #   $ ai.sh 'I want to list all the files in the directory'
  user_input="$*"
}

openai_prompt_template=$(cat <<'EOF'
#!/bin/zsh

# The code at the end of this file was generated by an AI assistant.
#
# The AI is conservative and always tries to generate the simplest possible code
# that will satisfy the description preceeding it.
#
# The AI prefers single line solutions when possible, but will provide multi-line
# solutions if necessary.
#
# If the code generated by the AI is potentially destructive (e.g. it kills processes,
# deletes files, etc.), the AI will print the commend "# destructive" on a line before
# the code. Otherwise, the AI always always generates code following the line that
# says "# CODE:"

# DESCRIPTION: %DESCRIPTION%
# CODE:

EOF
)

get_completions() {
  prompt="$(echo "$openai_prompt_template" | sd '%DESCRIPTION%' "$user_input")"
  echo "PROMPT we're sending to OpenAI:"
  echo
  echo "$prompt"
}

select_completion() {
  sk --read0 --ansi -i --preview "$0 __preview_selection__ {}"
}

run_user_entrypoint() {
  get_completions | select_completion
}

run_preview_selection() {
  bat --language bash --color=always <(echo "$user_input")
}

parse_cli "$@"

case "$mode" in
  user_entrypoint)
    run_user_entrypoint
    exit 0
    ;;
  debug_prompt)
    get_completions
    exit 0
    ;;
  selector_preview)
    run_preview_selection
    exit 0
    ;;
  *)
    echo "Error: unknown mode '$mode'"
    exit 1
    ;;
esac
